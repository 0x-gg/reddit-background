#!/usr/bin/env python2.7
"""
NAME

    reddit-background

SYNOPSIS

    reddit-background [options] [SUBREDDITS]

DESCRIPTION

    Set Mac OS X desktop backgrounds to images pulled from Reddit.

EXAMPLES

    reddit-backgrounds CarPorn:top:10:week {seasonal} EarthPorn:new

AUTHOR

    Rick Harris <rconradharris@gmail.com>
"""
import ConfigParser
import argparse
import datetime
import json
import os
import random
import re
import shutil
import socket
import subprocess
import sys
import urllib2
import urlparse
import uuid

__version__ = '0.2beta'

# Defaults
DEFAULT_SUBREDDIT_TOKENS = ['{seasonal}']
DEFAULT_CONFIG_PATH = "~/.reddit-background.conf"
DEFAULT_DOWNLOAD_DIRECTORY = "~/Reddit Backgrounds"
DEFAULT_USER_AGENT = "Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127 Firefox/2.0.0.11"

# Regexs
RE_RESOLUTION_DISPLAYS = re.compile("Resolution: (\d+)\sx\s(\d+)")

# Globals
_VERBOSITY = 0
_DOWNLOAD_DIRECTORY = None
_IMAGE_COUNT = 0


def set_verbosity(verbosity):
    global _VERBOSITY
    _VERBOSITY = verbosity


def get_verbosity():
    return _VERBOSITY


def set_download_directory(directory):
    global _DOWNLOAD_DIRECTORY
    _DOWNLOAD_DIRECTORY = directory


def get_download_directory():
    dirname = _DOWNLOAD_DIRECTORY or DEFAULT_DOWNLOAD_DIRECTORY
    return os.path.expanduser(dirname)


def set_image_count(image_count):
    global _IMAGE_COUNT
    _IMAGE_COUNT = image_count


def get_image_count():
    return _IMAGE_COUNT


def _safe_makedirs(name, mode=0777):
    if not os.path.exists(name):
        os.makedirs(name, mode=mode)


def warn(msg):
    """Print a warning to stderr"""
    print >> sys.stderr, "warning: {}".format(msg)


def log(msg, level=1):
    """Log to stderr

    -v is level 1
    -vv is level 2
    etc...
    """
    if get_verbosity() >= level:
        print >> sys.stderr, msg


def _parse_min_resolution(min_resolution):
    if not min_resolution:
        return None
    return map(int, min_resolution.split('x'))


def _min_resolution_str(min_resolution):
    return 'x'.join(map(str, min_resolution))


class Desktop(object):
    def __init__(self, num, min_resolution=None, subreddit_tokens=None,
                 image_urls=None):
        self.num = num
        self.min_resolution = min_resolution
        self.subreddit_tokens = subreddit_tokens or []
        self.image_urls = image_urls or []

    @property
    def subreddits(self):
        return [Subreddit.create_from_token(self, t)
                for t in self.subreddit_tokens]

    @property
    def download_directory(self):
        """Images are stored in ~/Reddit Backgrounds/Desktop 1"""
        subdir = 'Desktop {}'.format(self.num)
        return os.path.join(get_download_directory(), subdir)

    def _choose_image_urls(self):
        if self.image_urls:
            random.shuffle(self.image_urls)
            return self.image_urls

        log("Min resolution: {}".format(_min_resolution_str(self.min_resolution)))
        min_x, min_y = self.min_resolution
        image_urls = []
        for subreddit in self.subreddits:
            images = subreddit.fetch_images()
            log('{} images before sorting and filtering'.format(len(images)))
            _images = []
            for image in images:
                res_str = _min_resolution_str((image.width, image.height))
                if image.width >= min_x and image.height >= min_y:
                    log("Keeping {} with resolution {}".format(
                        image.url, res_str), level=2)
                    _images.append(image)
                else:
                    log("Rejecting {} with resolution {}".format(
                        image.url, res_str), level=2)

        image_urls.extend([i.url for i in _images])
        return image_urls

    def fetch_backgrounds(self):
        image_urls = self._choose_image_urls()
        log('Total candidate images: {0}'.format(len(image_urls)))

        image_count = get_image_count()
        if image_count <= 0:
            # image_count<=0 is set-background-mode.
            #
            # In set-background-mode, we download a single image per-desktop
            # and set that as the background.
            #
            # The opposite of set-background-mode is download-only-mode, when
            # image_count>0.
            #
            # In download-only-mode, we download the number of images
            # requested and DO NOT set the background (user configures OS X
            # to set background from folder)
            image_count = 1

        log('Number of images to download: {0}'.format(image_count))
        filenames = []
        while True:
            if len(filenames) >= image_count:
                break  # Reached user-specified limit...
            try:
                image_url = image_urls.pop()
            except IndexError:
                warn('ran out of images before reaching number_of_images'
                     ' limit')
                break
            try:
                filename = _download_to_directory(
                        image_url, self.download_directory)
            except URLOpenError:
                warn("unable to download '{}', skipping...".format(image_url))
                continue  # Try next image...
            else:
                filenames.append(filename)

        return filenames

    def set_background(self, filename):
        log('Setting background for desktop {0}'.format(self.num))
        script = 'tell application "System Events" to set picture of item'\
                 ' {num} of (a reference to every desktop) to "{filename}"'\
                 .format(num=self.num, filename=filename)
        return subprocess.check_output(['/usr/bin/osascript', '-e', script])


def _get_desktops_with_defaults():
    """Desktop objects populated with sensible defaults.

    Customizations will be performed by overriding these values, first using
    the config file and later command-line options.
    """
    p = subprocess.Popen(["/usr/sbin/system_profiler", "SPDisplaysDataType"],
                         stdout=subprocess.PIPE)
    (output, err) = p.communicate()
    matches = re.findall(RE_RESOLUTION_DISPLAYS, output)
    desktops = []
    for num, res in enumerate(matches, start=1):
        desktop = Desktop(num,
                          min_resolution=(int(res[0]), int(res[1])),
                          subreddit_tokens=DEFAULT_SUBREDDIT_TOKENS)
        desktops.append(desktop)
    return desktops


class URLOpenError(Exception):
    pass


def _urlopen(url):
    opener = urllib2.build_opener()
    opener.addheaders = [('User-Agent', DEFAULT_USER_AGENT)]
    try:
        return opener.open(url)
    except (socket.error,
            urllib2.HTTPError,
            urllib2.URLError):
        raise URLOpenError


def _get_extension_from_url(url):
    url_path = urlparse.urlparse(url).path
    parts = url_path.rsplit('.', 1)
    try:
        return parts[1]
    except IndexError:
        return None


def _download_to_directory(url, dirname):
    """Download a file to a particular directory"""
    _safe_makedirs(dirname)

    ext = _get_extension_from_url(url)
    basename = '.'.join([str(uuid.uuid4()), ext])
    filename = os.path.join(dirname, basename)

    log("Downloading '{0}' to '{1}'".format(url, filename))
    response = _urlopen(url)
    try:
        with open(filename, 'w') as f:
            f.write(response.read())
    finally:
        response.close()

    return filename


def _clear_download_directory():
    dirname = get_download_directory()
    if os.path.exists(dirname):
        shutil.rmtree(dirname)
    _safe_makedirs(dirname)


def _get_northern_hemisphere_season():
    """Source: http://stackoverflow.com/questions/16139306/determine-season-given-timestamp-in-python-using-datetime"""
    day = datetime.date.today().timetuple().tm_yday
    spring = range(80, 172)
    summer = range(172, 264)
    autumn = range(264, 355)
    if day in spring:
        return 'spring'
    elif day in summer:
        return 'summer'
    elif day in autumn:
        return 'autumn'
    else:
        return 'winter'


class Image(object):
    def __init__(self, width, height, url):
        self.width = width
        self.height = height
        self.url = url


class Subreddit(object):
    def __init__(self, desktop, name, sort='top', limit=25, timeframe='week'):
        self.desktop = desktop
        self.name = name
        self.sort = sort
        self.limit = limit
        self.timeframe = timeframe

    def fetch_images(self):
        url = 'http://reddit.com/r/{subreddit}/{sort}.json?t={timeframe}&limit={limit}'
        url = url.format(subreddit=self.name,
                         sort=self.sort,
                         timeframe=self.timeframe,
                         limit=self.limit)

        try:
            response = _urlopen(url)
        except URLOpenError:
            warn("error fetching images from subreddit '{0}',"
                 " skipping...".format(self.name))
            return []

        try:
            data = json.loads(response.read())
        finally:
            response.close()

        images = []
        for child in data['data']['children']:
            try:
                image_data = child['data']['preview']['images'][0]['source']
            except (KeyError, IndexError):
                continue
            else:
                image = Image(image_data['width'], image_data['height'], image_data['url'])
                images.append(image)

        return images

    @classmethod
    def handle_dynamic_subreddit_seasonal(cls, token_parts):
        """Dynamic subreddit handlers mutate token_parts in order to trigger
        dynamic behavior.
        """
        season = _get_northern_hemisphere_season().capitalize()
        token_parts[0] = '{}Porn'.format(season)

    @classmethod
    def create_from_token(cls, desktop, token):
        token_parts = token.split(':')

        # Handle any dynamic subreddits
        name = token_parts[0]
        if name.startswith('{') and name.endswith('}'):
            stripped_name = name[1:-1]
            handler_name = 'handle_dynamic_subreddit_{}'.format(stripped_name)
            func = getattr(cls, handler_name)
            func(token_parts)

        args = ('name', 'sort', 'limit', 'timeframe')
        ddict = {}
        for arg, value in zip(args, token_parts):
            ddict[arg] = value
        return cls(desktop, **ddict)

    def __repr__(self):
        return '<Subreddit r/{0}>'.format(self.name)


def _read_config_file(desktops):
    path = os.path.expanduser(DEFAULT_CONFIG_PATH)

    if not os.path.exists(path):
        return

    def parse_subreddit_tokens(desktop, section):
        try:
            tokens = map(lambda x: x.strip(),
                         config.get(section, 'subreddits').split(','))
        except ConfigParser.NoOptionError:
            pass
        else:
            if tokens:
                desktop.subreddit_tokens = tokens

    def parse_min_resolution(desktop, section):
        try:
            min_resolution = config.get(section, 'min_resolution')
        except ConfigParser.NoOptionError:
            pass
        else:
            min_resolution = _parse_min_resolution(min_resolution)
            if min_resolution:
                desktop.min_resolution = min_resolution

    config = ConfigParser.ConfigParser()
    with open(path) as f:
        config.readfp(f)

    for desktop in desktops:
        section = 'desktop{0}'.format(desktop.num)
        if section not in config.sections():
            section = 'default'
        parse_subreddit_tokens(desktop, section)
        parse_min_resolution(desktop, section)

    if 'default' in config.sections():
        try:
            set_image_count(config.getint('default', 'image_count'))
        except ConfigParser.NoOptionError:
            pass
        try:
            download_directory = config.get('default', 'download_directory')
        except ConfigParser.NoOptionError:
            pass
        else:
            if download_directory:
                set_download_directory(download_directory)


def _handle_cli_options(desktops):
    parser = argparse.ArgumentParser(
        description='set desktop background image from reddit')
    parser.add_argument('subreddits', metavar='SUBREDDITS', nargs='*',
            help='a list of subreddits')
    parser.add_argument('--desktop', type=int, default=0,
            help='set background for this desktop'
                 ' (default: sets background for all desktops)')
    parser.add_argument('--min-resolution',
            help='minimum resolution allowed for image'
                 ' (default: screen resolution used)')
    parser.add_argument('-v', '--verbose', action='count',
            help='log to stderr (use -vv for even more info)')
    parser.add_argument('--url',
            help='use image from this URL')
    parser.add_argument('--image-count', type=int,
            help="number of images to download (this only downloads the"
                 " images, it doesn't set the background)")
    parser.add_argument('--download-directory',
            help='directory to use to store images')
    parser.add_argument('--version',
                        action='version',
                        version=__version__)

    args = parser.parse_args()

    set_verbosity(args.verbose)

    if args.image_count is not None:
        set_image_count(args.image_count)

    if args.download_directory:
        set_download_directory(args.download_directory)

    if args.desktop:
        desktops = [d for d in desktops if d.num == args.desktop]

    for desktop in desktops:
        if args.url:
            desktop.image_urls = [args.url]
        if args.min_resolution:
            min_resolution = _parse_min_resolution(args.min_resolution)
            if min_resolution:
                desktop.min_resolution = min_resolution
        if args.subreddits:
            desktop.subreddit_tokens = args.subreddits


def main():
    # Configuration override order: defaults -> config-file -> cli-options
    desktops = _get_desktops_with_defaults()
    _read_config_file(desktops)
    _handle_cli_options(desktops)

    _clear_download_directory()

    for desktop in desktops:
        filenames = desktop.fetch_backgrounds()
        if get_image_count():
            log("Skipping setting background")
        else:
            if filenames:
                desktop.set_background(filenames[0])


if __name__ == "__main__":
    main()
