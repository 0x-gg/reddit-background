#!/usr/bin/env python
"""
NAME

    reddit-background

SYNOPSIS

    reddit-backgrounds [--desktop <DESKTOP>] [-h --help] [SUBREDDITS]

DESCRIPTION

    Set Mac OS X desktop backgrounds to images from pulled from Reddit.

EXAMPLES

    reddit-backgrounds CarPorn:top:10:week {seasonal} EarthPorn:new

AUTHOR

    Rick Harris <rconradharris@gmail.com>
"""
import ConfigParser
import argparse
import collections
import datetime
import json
import os
import random
import re
import shutil
import subprocess
import sys
import urllib2
import uuid


CONFIG_PATH = "~/.reddit-background.conf"
DOWNLOAD_DIRECTORY = "~/.background-images"
RE_RESOLUTION_IN_TITLE = re.compile(".*\[\s*(\d+)\s*[xX]\s*(\d+)\s*\].*")
DEFAULT_MIN_RESOLUTION = '1024x768'


def _run_apple_script(script):
    return subprocess.check_output(['osascript', '-e', script])


def _set_desktop_background(idx, filename):
    script = 'tell application "System Events" to set picture of item'\
             ' {idx} of (a reference to every desktop) to "{filename}"'\
             .format(idx=idx, filename=filename)
    return _run_apple_script(script)


def _get_number_of_desktops():
    script = 'tell application "System Events" to return count of a'\
             ' reference to every desktop'
    return int(_run_apple_script(script).strip())
    

def _urlopen(url):
    user_agent = "Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127 Firefox/2.0.0.11" 
    opener = urllib2.build_opener()
    opener.addheaders = [('User-Agent', user_agent)]
    return opener.open(url)
    

def _download(url, filename):
    response = _urlopen(url)
    try:
        with open(filename, 'w') as f:
            f.write(response.read())
    finally:
        response.close()


def _download_image(image_url):
    dirname = os.path.expanduser(DOWNLOAD_DIRECTORY)
    basename = "%s.jpg" % uuid.uuid4()
    filename = os.path.join(dirname, basename)
    _download(image_url, filename)
    return filename


def _select_and_download_image_for_desktop(image_urls):
    image_urls = image_urls[:]

    random.shuffle(image_urls)

    for image_url in image_urls:
        try:
            return _download_image(image_url)
        except urllib2.HTTPError:
            pass  # Try next image...


def _clear_download_directory():
    dirname = os.path.expanduser(DOWNLOAD_DIRECTORY)
    if os.path.exists(dirname):
        shutil.rmtree(dirname)
    os.makedirs(dirname)


def _get_northern_hemisphere_season():
    """Source: http://stackoverflow.com/questions/16139306/determine-season-given-timestamp-in-python-using-datetime"""
    day = datetime.date.today().timetuple().tm_yday
    spring = range(80, 172)
    summer = range(172, 264)
    autumn = range(264, 355)
    if day in spring:
      return 'spring'
    elif day in summer:
      return 'summer'
    elif day in autumn:
      return 'autumn'
    else:
      return 'winter'


class Subreddit(object):
    def __init__(self, name, sort='top', limit=25, timeframe='week'):
        self.name = name
        self.sort = sort
        self.limit = limit
        self.timeframe = timeframe

    @staticmethod
    def _fetch_subreddit_data(subreddit, sort, limit, timeframe):
        url = 'http://reddit.com/r/{subreddit}/{sort}.json?t={timeframe}&limit={limit}'
        url = url.format(subreddit=subreddit,
                         sort=sort,
                         timeframe=timeframe,
                         limit=limit)
        response = _urlopen(url)
        try:
            return json.loads(response.read())
        finally:
            response.close()

    @staticmethod
    def _meets_resolution_criteria(title, min_resolution):
        if not min_resolution:
            return True

        min_x, min_y = map(int, min_resolution.split('x'))

        match = RE_RESOLUTION_IN_TITLE.match(title)

        if not match:
            return False

        resolution_x = int(match.group(1))
        resolution_y = int(match.group(2))

        return resolution_x >= min_x and resolution_y >= min_y

    @classmethod
    def _get_image_urls_from_data(cls, data, min_resolution=None):
        image_urls = []
        for child in data['data']['children']:
            title = child['data']['title']
            url = child['data']['url']

            if 'imgur.com' in url and not url.endswith('.jpg'):
                url += '.jpg'

            if not url.endswith('.jpg'):
                continue

            if not cls._meets_resolution_criteria(title, min_resolution):
                continue

            image_urls.append(url)

        return image_urls

    def fetch_image_urls(self, min_resolution=None):
        data = self._fetch_subreddit_data(
                self.name, self.sort, self.limit, self.timeframe)
        return self._get_image_urls_from_data(
                data, min_resolution=min_resolution)

    @classmethod
    def create_from_token_parts(cls, token_parts):
        args = ('name', 'sort', 'limit', 'timeframe')
        ddict = {}
        for arg, value in zip(args, token_parts):
            ddict[arg] = value
        return cls(**ddict)

    def __repr__(self):
        return '<Subreddit r/{0}>'.format(self.name)


def _parse_subreddit_token(token):
    token_parts = token.split(':')

    name = token_parts[0]

    if name == '{seasonal}':
        token_parts[0] = '%sporn' % _get_northern_hemisphere_season()

    return Subreddit.create_from_token_parts(token_parts)


def _get_desktop_range():
    num_desktops = _get_number_of_desktops()
    return map(lambda x: x + 1, range(num_desktops))


def _read_config_file(desktop_info):
    path = os.path.expanduser(CONFIG_PATH)

    if not os.path.exists(path):
        return

    def parse_subreddits(info, section):
        tokens = map(lambda x: x.strip(),
                     config.get(section, 'subreddits').split(','))

        subreddits = [_parse_subreddit_token(t) for t in tokens]
        if subreddits:
            info['subreddits'] = subreddits

    def parse_min_resolution(info, section):
        try:
            min_resolution = config.get(section, 'min_resolution')
        except ConfigParser.NoOptionError:
            pass
        else:
            info['min_resolution'] = min_resolution

    def parse_section(info, section):
        if not info.get('subreddits'):
            parse_subreddits(info, section)

        if not info.get('min_resolution'):
            parse_min_resolution(info, section)

    config = ConfigParser.ConfigParser()
    with open(path) as f:
        config.readfp(f)

    for desktop in _get_desktop_range():
        section = 'desktop{0}'.format(desktop)

        if section not in config.sections():
            section = 'default'

        parse_section(desktop_info[desktop], section)


def _handle_cli_options(desktop_info):
    parser = argparse.ArgumentParser(
        description='Set desktop background image from reddit')
    parser.add_argument('subreddits', metavar='SUBREDDITS', nargs='*',
                       help='A list of subreddits')
    parser.add_argument('--desktop', type=int, default=0,
            help='Only set background for this desktop'
                 ' (default: Set all desktops)')
    parser.add_argument('--min-resolution',
            help='Minimum resolution of selected image'
                 ' (default: 1024x768)')

    args = parser.parse_args()

    if args.desktop:
        desktops = [args.desktop]
    else:
        desktops = _get_desktop_range()

    for desktop in desktops:
        if args.min_resolution:
            desktop_info[desktop]['min_resolution'] = args.min_resolution

        subreddits = []
        for token in args.subreddits:
            subreddit = _parse_subreddit_token(token)
            subreddits.append(subreddit)

        if subreddits:
            desktop_info[desktop]['subreddits'] = subreddits


def _use_defaults(desktop_info):
    for desktop in _get_desktop_range():
        info = desktop_info[desktop]

        if not info.get('subreddits'):
            # Seasonal seems like a pretty good default
            subreddit = _parse_subreddit_token('{seasonal}')
            info['subreddits'] = [subreddit]

        if not info.get('min_resolution'):
            info['min_resolution'] = DEFAULT_MIN_RESOLUTION


def main():
    desktop_info = collections.defaultdict(dict)

    # Configuration override chain:
    #   CLI options overrides config file
    #   config file overrides defaults
    _handle_cli_options(desktop_info)
    _read_config_file(desktop_info)
    _use_defaults(desktop_info)

    _clear_download_directory()

    for desktop, info in desktop_info.iteritems():
        # Accumulate images URL across subreddits
        image_urls = []
        for subreddit in info['subreddits']:
            subreddit_urls = subreddit.fetch_image_urls(
                    min_resolution=info['min_resolution'])

            image_urls.extend(subreddit_urls)

        # Pick one
        filename = _select_and_download_image_for_desktop(image_urls)

        # If we found one, set the background
        if filename:
            _set_desktop_background(desktop, filename)


if __name__ == "__main__":
    main()
