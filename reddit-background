#!/usr/bin/env python2.7
"""
NAME

    reddit-background

SYNOPSIS

    reddit-backgrounds [--desktop <DESKTOP>] [-h --help] [SUBREDDITS]

DESCRIPTION

    Set Mac OS X desktop backgrounds to images from pulled from Reddit.

EXAMPLES

    reddit-backgrounds CarPorn:top:10:week {seasonal} EarthPorn:new

AUTHOR

    Rick Harris <rconradharris@gmail.com>
"""
import ConfigParser
import argparse
import datetime
import json
import os
import random
import re
import shutil
import socket
import subprocess
import sys
import urllib2
import urlparse
import uuid

__version__ = '0.1beta'

# Defaults
DEFAULT_SUBREDDIT_TOKENS = ['{seasonal}']
DEFAULT_CONFIG_PATH = "~/.reddit-background.conf"
DEFAULT_IMAGE_EXTENSIONS = set(['jpg', 'jpeg', 'png'])
DEFAULT_DOWNLOAD_DIRECTORY = "~/Reddit Backgrounds"

# Regexs
RE_RESOLUTION_IN_TITLE = re.compile(".*\[\s*(\d+)\s*[xX]\s*(\d+)\s*\].*")
RE_RESOLUTION_DISPLAYS = re.compile("Resolution: (\d+)\sx\s(\d+)")

# Globals
_VERBOSITY = 0
_DOWNLOAD_DIRECTORY = None
_IMAGE_COUNT = 0


def set_verbosity(verbosity):
    global _VERBOSITY
    _VERBOSITY = verbosity


def get_verbosity():
    return _VERBOSITY


def set_download_directory(directory):
    global _DOWNLOAD_DIRECTORY
    _DOWNLOAD_DIRECTORY = directory


def get_download_directory():
    dirname = _DOWNLOAD_DIRECTORY or DEFAULT_DOWNLOAD_DIRECTORY
    return os.path.expanduser(dirname)


def set_image_count(image_count):
    global _IMAGE_COUNT
    _IMAGE_COUNT = image_count


def get_image_count():
    return _IMAGE_COUNT


def _safe_makedirs(name, mode=0777):
    if not os.path.exists(name):
        os.makedirs(name, mode=mode)


def warn(msg):
    """Print a warning to stderr"""
    print >> sys.stderr, "warning: {}".format(msg)


def log(msg, level=1):
    """Log to stderr

    -v is level 1
    -vv is level 2
    etc...
    """
    if get_verbosity() >= level:
        print >> sys.stderr, msg


def _run_apple_script(script):
    return subprocess.check_output(['/usr/bin/osascript', '-e', script])


def _set_desktop_background(idx, filename):
    log('Setting background for desktop {0}'.format(idx))
    script = 'tell application "System Events" to set picture of item'\
             ' {idx} of (a reference to every desktop) to "{filename}"'\
             .format(idx=idx, filename=filename)
    return _run_apple_script(script)


def _parse_min_resolution(min_resolution):
    if not min_resolution:
        return None
    return map(int, min_resolution.split('x'))


def _min_resolution_str(min_resolution):
    return 'x'.join(map(str, min_resolution))


class Desktop(object):
    def __init__(self, num, min_resolution=None, subreddit_tokens=None,
                 image_urls=None):
        self.num = num
        self.min_resolution = min_resolution
        self.subreddit_tokens = subreddit_tokens or []
        self.image_urls = image_urls or []

    def _get_image_urls_from_subreddits(self):
        subreddits = [Subreddit.create_from_token(self, t)
                      for t in self.subreddit_tokens]
        log("Subreddits: {}".format([s.name for s in subreddits]))
        image_urls = []
        for subreddit in subreddits:
            log("Get image URLS from subreddit: {}".format(subreddit))
            try:
                urls = subreddit.fetch_image_urls()
            except URLOpenError:
                warn("error fetching URLS from subreddit '{0}',"
                     " skipping...".format(subreddit.name))
            else:
                image_urls.extend(urls)

        return image_urls

    @property
    def download_directory(self):
        """Images are stored in ~/Reddit Backgrounds/Desktop 1"""
        subdir = 'Desktop {}'.format(self.num)
        return os.path.join(get_download_directory(), subdir)

    def fetch_backgrounds(self):
        log("Min resolution: {}".format(_min_resolution_str(self.min_resolution)))
        if self.image_urls:
            image_urls = self.image_urls
        else:
            image_urls = self._get_image_urls_from_subreddits()
            log('Total candidate images across subreddits: {0}'.format(len(image_urls)))

        random.shuffle(image_urls)

        image_count = get_image_count()
        if image_count <= 0:
            # image_count<=0 is set-background-mode.
            #
            # In set-background-mode, we download a single image per-desktop
            # and set that as the background.
            #
            # The opposite of set-background-mode is download-only-mode, when
            # image_count>0.
            #
            # In download-only-mode, we download the number of images
            # requested and DO NOT set the background (user configures OS X
            # to set background from folder)
            image_count = 1

        log('Number of images to download: {0}'.format(image_count))
        filenames = []
        while True:
            if len(filenames) >= image_count:
                break  # Reached user-specified limit...
            try:
                image_url = image_urls.pop()
            except IndexError:
                warn('ran out of images before reaching number_of_images'
                     ' limit')
                break
            try:
                filename = _download_image(image_url, self.download_directory)
            except URLOpenError:
                continue  # Try next image...
            else:
                filenames.append(filename)

        return filenames

    def set_background(self, filename):
        _set_desktop_background(self.num, filename)


def _get_desktops_with_defaults():
    """Desktop objects populated with sensible defaults.

    Customizations will be performed by overriding these values, first using
    the config file and later command-line options.
    """
    p = subprocess.Popen(["/usr/sbin/system_profiler", "SPDisplaysDataType"],
                         stdout=subprocess.PIPE)
    (output, err) = p.communicate()
    matches = re.findall(RE_RESOLUTION_DISPLAYS, output)
    desktops = []
    for num, res in enumerate(matches, start=1):
        desktop = Desktop(num,
                          min_resolution=(int(res[0]), int(res[1])),
                          subreddit_tokens=DEFAULT_SUBREDDIT_TOKENS)
        desktops.append(desktop)
    return desktops


class URLOpenError(Exception):
    pass


def _urlopen(url):
    user_agent = "Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127 Firefox/2.0.0.11"
    opener = urllib2.build_opener()
    opener.addheaders = [('User-Agent', user_agent)]
    try:
        return opener.open(url)
    except (socket.error,
            urllib2.HTTPError,
            urllib2.URLError):
        raise URLOpenError


def _get_extension_from_url(url):
    url_path = urlparse.urlparse(url).path
    parts = url_path.rsplit('.', 1)
    try:
        return parts[1]
    except IndexError:
        return None


def _download_image(image_url, dirname):
    """Download an image to a particular directory"""
    ext = _get_extension_from_url(image_url)
    assert ext, "No extension found for image!"

    _safe_makedirs(dirname)

    basename = '.'.join([str(uuid.uuid4()), ext])
    filename = os.path.join(dirname, basename)

    log("Downloading '{0}' to '{1}'".format(image_url, filename))
    response = _urlopen(image_url)
    try:
        with open(filename, 'w') as f:
            f.write(response.read())
    finally:
        response.close()

    return filename


def _clear_download_directory():
    dirname = get_download_directory()
    if os.path.exists(dirname):
        shutil.rmtree(dirname)
    _safe_makedirs(dirname)


def _get_northern_hemisphere_season():
    """Source: http://stackoverflow.com/questions/16139306/determine-season-given-timestamp-in-python-using-datetime"""
    day = datetime.date.today().timetuple().tm_yday
    spring = range(80, 172)
    summer = range(172, 264)
    autumn = range(264, 355)
    if day in spring:
        return 'spring'
    elif day in summer:
        return 'summer'
    elif day in autumn:
        return 'autumn'
    else:
        return 'winter'


class Post(object):
    def __init__(self, subreddit, title, url):
        self.subreddit = subreddit
        self.title = title
        self.url = url

    def get_image_resolution(self):
        match = RE_RESOLUTION_IN_TITLE.match(self.title)
        if not match:
            return (None, None)
        resolution_x = int(match.group(1))
        resolution_y = int(match.group(2))
        return resolution_x, resolution_y

    def fetch_image_url(self):
        url = self.url

        ext = _get_extension_from_url(url)

        if ext in DEFAULT_IMAGE_EXTENSIONS:
            return url
        elif 'imgur.com' in url:
            return '{0}.jpg'.format(url)
        else:
            return None


class Subreddit(object):
    def __init__(self, desktop, name, sort='top', limit=25, timeframe='week'):
        self.desktop = desktop
        self.name = name
        self.sort = sort
        self.limit = limit
        self.timeframe = timeframe

    def _fetch_posts(self):
        url = 'http://reddit.com/r/{subreddit}/{sort}.json?t={timeframe}&limit={limit}'
        url = url.format(subreddit=self.name,
                         sort=self.sort,
                         timeframe=self.timeframe,
                         limit=self.limit)

        response = _urlopen(url)

        try:
            data = json.loads(response.read())
        finally:
            response.close()

        posts = []
        for child in data['data']['children']:
            data = child['data']
            post = Post(self, data['title'], data['url'])
            posts.append(post)

        return posts

    def fetch_image_urls(self):
        min_x, min_y = self.desktop.min_resolution
        posts = self._fetch_posts()
        image_urls = []
        for post in posts:
            image_url = post.fetch_image_url()
            if not image_url:
                continue

            # Check minimum resolution criteria
            res_x, res_y = post.get_image_resolution()
            if res_x is not None and res_y is not None:
                res_str = _min_resolution_str((res_x, res_y))
                if res_x >= min_x and res_y >= min_y:
                    log("Keeping {} with resolution {}".format(
                        image_url, res_str), level=2)
                    image_urls.append(image_url)
                else:
                    log("Rejecting {} with resolution {}".format(
                        image_url, res_str), level=2)
            else:
                log("Rejecting {} with no resolution information".format(
                    image_url), level=2)

        log('Found {0} candidate images from {1}'.format(len(image_urls),
                                                         self.name))
        return image_urls

    @classmethod
    def create_from_token(cls, desktop, token):
        token_parts = token.split(':')

        name = token_parts[0]

        if name == '{seasonal}':
            token_parts[0] = '%sporn' % _get_northern_hemisphere_season()

        args = ('name', 'sort', 'limit', 'timeframe')
        ddict = {}
        for arg, value in zip(args, token_parts):
            ddict[arg] = value
        return cls(desktop, **ddict)

    def __repr__(self):
        return '<Subreddit r/{0}>'.format(self.name)


def _read_config_file(desktops):
    path = os.path.expanduser(DEFAULT_CONFIG_PATH)

    if not os.path.exists(path):
        return

    def parse_subreddit_tokens(desktop, section):
        try:
            tokens = map(lambda x: x.strip(),
                         config.get(section, 'subreddits').split(','))
        except ConfigParser.NoOptionError:
            pass
        else:
            if tokens:
                desktop.subreddit_tokens = tokens

    def parse_min_resolution(desktop, section):
        try:
            min_resolution = config.get(section, 'min_resolution')
        except ConfigParser.NoOptionError:
            pass
        else:
            min_resolution = _parse_min_resolution(min_resolution)
            if min_resolution:
                desktop.min_resolution = min_resolution

    config = ConfigParser.ConfigParser()
    with open(path) as f:
        config.readfp(f)

    for desktop in desktops:
        section = 'desktop{0}'.format(desktop.num)
        if section not in config.sections():
            section = 'default'
        parse_subreddit_tokens(desktop, section)
        parse_min_resolution(desktop, section)

    if 'default' in config.sections():
        try:
            set_image_count(config.getint('default', 'image_count'))
        except ConfigParser.NoOptionError:
            pass
        try:
            download_directory = config.get('default', 'download_directory')
        except ConfigParser.NoOptionError:
            pass
        else:
            if download_directory:
                set_download_directory(download_directory)


def _handle_cli_options(desktops):
    parser = argparse.ArgumentParser(
        description='set desktop background image from reddit')
    parser.add_argument('subreddits', metavar='SUBREDDITS', nargs='*',
            help='a list of subreddits')
    parser.add_argument('--desktop', type=int, default=0,
            help='only set background for this desktop'
                 ' (default: Set all desktops)')
    parser.add_argument('--min-resolution',
            help='minimum resolution allowed for image'
                 ' (default: screen resolution used)')
    parser.add_argument('-v', '--verbose', action='count',
            help='log to stderr (use -vv for even more info)')
    parser.add_argument('--url',
            help='use image from this URL')
    parser.add_argument('--image-count', type=int,
            help="number of images to download (this only downloads the"
                 " images, it doesn't set the background)")
    parser.add_argument('--download-directory',
            help='directory to use to store images')
    parser.add_argument('--version',
                        action='version',
                        version=__version__)

    args = parser.parse_args()

    set_verbosity(args.verbose)

    if args.image_count is not None:
        set_image_count(args.image_count)

    if args.download_directory:
        set_download_directory(args.download_directory)

    if args.desktop:
        desktops = [d for d in desktops if d.num == args.desktop]

    for desktop in desktops:
        if args.url:
            desktop.image_urls = [args.url]
        if args.min_resolution:
            min_resolution = _parse_min_resolution(args.min_resolution)
            if min_resolution:
                desktop.min_resolution = min_resolution
        if args.subreddits:
            desktop.subreddit_tokens = args.subreddits


def main():
    # Configuration override order: defaults -> config-file -> cli-options
    desktops = _get_desktops_with_defaults()
    _read_config_file(desktops)
    _handle_cli_options(desktops)

    _clear_download_directory()

    for desktop in desktops:
        filenames = desktop.fetch_backgrounds()
        if get_image_count():
            log("Skipping setting background")
        else:
            if filenames:
                desktop.set_background(filenames[0])


if __name__ == "__main__":
    main()
